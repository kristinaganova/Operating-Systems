2016-SE-04 
В текущата директория има само обикновени файлове (без директории). Да се напише
bash script, който приема 2 позиционни параметъра – числа, който мести файловете от текущата директория 
към нови директории (a, b и c, които тря да бъдат създадени), като определен файл се
мести към директория ’a’, само ако той има по-малко редове от първи позиционен параметър, мести
към директория ’b’, ако редове са между първи и втори позиционен параметър и в ’c’ в останалите
случаи.

#!/bin/bash

if [[ "${#}" -ne 2 ]] ;
then 
    echo "Two parameters allowed"
    exit 1
fi

if [[ ! "${1}" =~ ^[0-9]+$ ]] || [[ ! "${2}" =~ ^[0-9]+$ ]] ;
then 
    echo "Parameters should be numbers"
    exit 2
fi

for file in $(find . -mindepth 1 -maxdepth 1 -type f ) 
do
    lines_count=$(cat "${file}" | wc -l)
    if [[ "${lines_count}" -lt "${1}" ]] ;
    then 
        mv "${file}" ./a
    elif [[ "${lines_count}" -gt "${1}" ]] || [[ "${lines_count}" -lt "${2}" ]] ;
    then 
        mv "${file}" ./b
    else
        mv "${file}" ./c
    fi
done


 2017-IN-01 
 Напишете скрипт, който приема три задължителни позицонни аргумента:
• име на фаил
• низ1
• низ2
Файлът е текстови, и съдържа редове във формат:
ключ=стойност
където стойност може да бъде:
• празен низ, т.е. редът е ключ=
• низ, състоящ се от един или повече термове, разделени с интервали, т.е., редът е ключ=𝑡1
𝑡2
𝑡3
Някъде във файла:
• се съдържа един ред с ключ първия подаден низ (низ1);
• и може да се съдържа един ред с ключ втория подаден низ (низ2).
Скриптът трябва да променя реда с ключ низ2 така, че обединението на термовете на редовете с ключове низ1 и низ2 да включва всеки терм еднократно.
Примерен входен файл:
$ cat z1.txt
FOO=73
BAR=42
BAZ=
ENABLED_OPTIONS=a b c d
ENABLED_OPTIONS_EXTRA=c e f
Примерно извикване:
$ ./a.sh z1.txt ENABLED_OPTIONS ENABLED_OPTIONS_EXTRA
Изходен файл:
$ cat z1.txt
FOO=73
BAR=42
7
BAZ=
ENABLED_OPTIONS=a b c d
ENABLED_OPTIONS_EXTRA=e f

#!/bin/bash

if [[ "${#}" -ne 3 ]] ;
then
    echo "Invalid number of parameters"
    exit 1
fi

if [[ ! -f "${1}" ]] ;
then
    echo "Invalid file"
    exit 2
fi

if [[ -z "${3}" ]] || [[ -z "${2}" ]] ;
then
    echo "Empty string"
    exit 3
fi

terms1=$(egrep "^${2}=.*" "${1}" | cut -d '=' -f 2 | tr ' ' '\n' )
terms2=$(egrep "^${3}=.*" "${1}" | cut -d '=' -f 2 | tr ' ' '\n' )

for line in ${terms2} ;
do
    if ! echo "${terms1}" | grep -qxF "${line}" ;
    then
       result+="${line} "
    fi
done

sed -i -E "s:(${3}=).*:\1${result}:g" "${1}"

2017-SE-01
Напишете скрипт, който получава задължителен първи позиционен параметър – директория и незадължителен втори – число. Скриптът трябва да проверява подадената директория и нейните под-директории и да извежда имената на:
а) при подаден на скрипта втори параметър – всички файлове с брой hardlink-ове поне равен на
параметъра;
б) при липса на втори параметър – всички symlink-ове с несъществуващ destination (счупени symlinkове).
Забележка:За удобство приемаме, че ако има подаден втори параметър, то той е число

#!/bin/bash

if [[ ! -d "${1}" ]] ;
then
    echo "First parameter should be a directory"
    exit 1
fi

if [[ "${#}" -eq 2 ]] ;
then
    if [[ "${2}" =~ ^[0-9]+$ ]] ;
    then
        find "${1}" -mindepth 1 -type f  -exec stat -c "%h %n\n" {} \; | awk -v var=${2} '{if ($1>=var) print $2}'
    else
        echo "Invalid second parameter"
        exit 2
    fi
elif [[ "${#}" -eq 1 ]] ;
then
    find "${1}" -mindepth 1 -type l -exec test ! -e {} \; -print
fi

2017-SE-02 
Напишете скрипт, който приема три задължителни позиционни параметра - директория
SRC, директория DST (която не трябва да съдържа файлове) и низ АBC. Ако скриптът се изпълнява
от root потребителя, то той трябва да намира всички файлове в директорията SRC и нейните поддиректории, 
които имат в името си като под-низ АBC, и да ги мести в директорията DST, запазвайки
директорийната структура (но без да запазва мета-данни като собственик и права, т.е. не ни интересуват 
тези параметри на новите директории, които скриптът би генерирал в DST).
Пример:
• в SRC (/src) има следните файлове:
/src/foof.txt
/src/1/bar.txt
/src/1/foo.txt
/src/2/1/foobar.txt
/src/2/3/barf.txt
• DST (/dst) е празна директория
• зададения низ е foo
Резултат:
• в SRC има следните файлове:
/src/1/bar.txt
/src/2/3/barf.txt
• в DST има следните файлове:
8
/dst/foof.txt
/dst/1/foo.txt
/dst/2/1/foobar.txt


#!/bin/bash

if [[ "${#}" -ne 3 ]] ;
then
    echo "There should be 3 parameters"
    exit 1
fi

src="${1}"

if [[ ! -d "${src}" ]] ;
then
    echo "1st param should be a directory"
    exit 2
fi

dst="${2}"

if [[ -d "${dst}" ]] ;
then
    if [[  $(find "${dst}" -mindepth 1 | wc -l) -ne 0 ]] ;
    then
        echo "The destination folder should be empty"
        exit 3
    fi
else
    echo "Incorrect dest dir"
    exit 4
fi

abc="${3}"
if [[ -z "${abc}" ]]
then
    echo "Empty string"
    exit 5
fi

if [[ $(id -u) -ne 0 ]] ;
then
    echo "Only root cat execute this script"
    exit 6
fi

files=$(find "${src}" -type f -name "*${abc}*")
echo "${files}"
for file in $files ;
do
    src_path=$(realpath "${src}")
    path=$(realpath "${file}" | rev | cut -d '/' -f 2- | rev | sed "s:^${src_path}/::g")
    mkdir -p "${dst}/${path}"

    mv "${file}" "${dst}/${path}/"

done



2018-SE-02 
Напишете скрипт, който приема два позиционни аргумента – име на текстови файл и
директория. Директорията не трябва да съдържа обекти, а текстовият файл (US-ASCII) е стенограма
и всеки ред е в следния формат:
ИМЕ ФАМИЛИЯ (уточнения): Реплика
където:
• ИМЕ ФАМИЛИЯ присъстват задължително;
• ИМЕ и ФАМИЛИЯ се състоят само от малки/главни латински букви и тирета;
• (уточнения) не е задължително да присъстват;
• двоеточието ‘:’ присъства задължително;
10
• Репликата не съдържа знаци за нов ред;
• в стринга преди двоеточието ‘:’ задължително има поне един интервал между ИМЕ и ФАМИЛИЯ;
• наличието на други интервали където и да е на реда е недефинирано.
Примерен входен файл:
John Lennon (The Beatles): Time you enjoy wasting, was not wasted.
Roger Waters: I'm in competition with myself and I'm losing.
John Lennon:Reality leaves a lot to the imagination.
Leonard Cohen:There is a crack in everything, that's how the light gets in.
Скриптът трябва да:
• създава текстови файл dict.txt в посочената директория, който на всеки ред да съдържа:
ИМЕ ФАМИЛИЯ;НОМЕР
където:
– ИМЕ ФАМИЛИЯ е уникален участник в стенограмата (без да се отчитат уточненията);
– НОМЕР е уникален номер на този участник, избран от вас.
• създава файл НОМЕР.txt в посочената директория, който съдържа всички (и само) редовете на
дадения участник.

 #!/bin/bash

if [[ ${#} -ne 2 ]] ;
then
    echo "Invalid number of parameters"
    exit 1
fi

file=${1}
dir=${2}

if [[ ! -f "${file}" ]] ;
then
    echo "Invalid file parameter"
    exit 2
fi

if [[ ! -d "${dir}"  ]] ;
then
    echo "Invalid directory parameter"
    exit 3
fi

valid_lines=$(egrep "^[a-zA-Z-]+ [a-zA-Z-]+( \(.*\))?:.*" "${file}")

if [[ ! -f "${dir}/dict.txt" ]] ;
then
    touch "${dir}/dict.txt"
fi

dict="${dir}/dict.txt"
counter=1

while read person ;
do
    if grep -q "${person}" "${dict}" ;
    then
        continue
    fi
    echo "${person}:${counter}" >> "${dict}"
    if [[ ! -f "${counter}" ]] ;
    then
        touch "${dir}/${counter}.txt"
    fi

    grep "${person}" <(echo "${valid_lines}") | cut -d ":" -f 2  | sed "s:^ ::g" > ${dir}/${counter}.txt
    ((counter+=1 ))
done < <(echo "${valid_lines}" | cut -d ':' -f 1 | sed "s:(.*)::g" | sort | uniq ) ;


2018-SE-03 Напишете скрипт, който приема два позиционни аргумента – имена на текстови файлове
в CSV формат:
8,foo,bar,baz
2,quz,,foo
12,1,3,foo
3,foo,,
5,,bar,
7,,,
4,foo,bar,baz
Валидни са следните условия:
• CSV файловете представляват таблица, като всеки ред на таблицата е записан на отделен ред;
• на даден ред всяко поле (колона) е разделено от останалите със запетая;
• броят на полетата на всеки ред е константа;
• в полетата не може да присъства запетая, т.е., запетаята винаги е разделител между полета;
• ако във файла присъстват интервали, то това са данни от дадено поле;
• първото поле на всеки ред е число, което представлява идентификатор на реда (ID).
Примерно извикване: ./foo.sh a.csv b.csv
Скриптът трябва да чете a.csv и на негова база да създава b.csv по следния начин:
• някои редове във файла се различават само по колоната ID, и за тях казваме, че формират множество 𝐴𝑖
• за всяко такова множество 𝐴𝑖
да се оставя само един ред - този, с най-малка стойност на ID-то;
• редовете, които не са членове в някое множество 𝐴𝑖
се записват в изходния файл без промяна.

#!/bin/bash

if [[ "${#}" -ne 2 ]] ;
then
    echo "Two parameters"
    exit 1
fi

input="${1}"

if [[ ! -f "${input}" ]] ;
then
    echo "Invalid file"
    exit 2
fi

output="${2}"
if [[ -e "${output}" ]] ;
then
    > "${output}"
else
    touch "${output}"
fi

removed_id=$(cut -d ',' -f 2- "${input}" | sort | uniq)
while read line ;
do
    count=$(egrep -o "^[0-9]+,${line}$" "${input}" | wc -l)
    if [[ "${count}" -lt 2 ]] ;
    then
        whole_line=$(egrep "^[0-9]+,${line}$" "${input}")
        echo "${whole_line}" >> "${output}"
    else
        echo "$(egrep "^[0-9]+,${line}$" "${input}" | sort -n -k 1 -t ',' | head -n 1)" >> "${output}"
    fi
done <<< "${removed_id}"
