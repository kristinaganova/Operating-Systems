2016-SE-04 
В текущата директория има само обикновени файлове (без директории). Да се напише
bash script, който приема 2 позиционни параметъра – числа, който мести файловете от текущата директория 
към нови директории (a, b и c, които тря да бъдат създадени), като определен файл се
мести към директория ’a’, само ако той има по-малко редове от първи позиционен параметър, мести
към директория ’b’, ако редове са между първи и втори позиционен параметър и в ’c’ в останалите
случаи.

#!/bin/bash

if [[ "${#}" -ne 2 ]] ;
then 
    echo "Two parameters allowed"
    exit 1
fi

if [[ ! "${1}" =~ ^[0-9]+$ ]] || [[ ! "${2}" =~ ^[0-9]+$ ]] ;
then 
    echo "Parameters should be numbers"
    exit 2
fi

for file in $(find . -mindepth 1 -maxdepth 1 -type f ) 
do
    lines_count=$(cat "${file}" | wc -l)
    if [[ "${lines_count}" -lt "${1}" ]] ;
    then 
        mv "${file}" ./a
    elif [[ "${lines_count}" -gt "${1}" ]] || [[ "${lines_count}" -lt "${2}" ]] ;
    then 
        mv "${file}" ./b
    else
        mv "${file}" ./c
    fi
done


 2017-IN-01 
 Напишете скрипт, който приема три задължителни позицонни аргумента:
• име на фаил
• низ1
• низ2
Файлът е текстови, и съдържа редове във формат:
ключ=стойност
където стойност може да бъде:
• празен низ, т.е. редът е ключ=
• низ, състоящ се от един или повече термове, разделени с интервали, т.е., редът е ключ=𝑡1
𝑡2
𝑡3
Някъде във файла:
• се съдържа един ред с ключ първия подаден низ (низ1);
• и може да се съдържа един ред с ключ втория подаден низ (низ2).
Скриптът трябва да променя реда с ключ низ2 така, че обединението на термовете на редовете с ключове низ1 и низ2 да включва всеки терм еднократно.
Примерен входен файл:
$ cat z1.txt
FOO=73
BAR=42
BAZ=
ENABLED_OPTIONS=a b c d
ENABLED_OPTIONS_EXTRA=c e f
Примерно извикване:
$ ./a.sh z1.txt ENABLED_OPTIONS ENABLED_OPTIONS_EXTRA
Изходен файл:
$ cat z1.txt
FOO=73
BAR=42
7
BAZ=
ENABLED_OPTIONS=a b c d
ENABLED_OPTIONS_EXTRA=e f

#!/bin/bash

if [[ "${#}" -ne 3 ]] ;
then
    echo "Invalid number of parameters"
    exit 1
fi

if [[ ! -f "${1}" ]] ;
then
    echo "Invalid file"
    exit 2
fi

if [[ -z "${3}" ]] || [[ -z "${2}" ]] ;
then
    echo "Empty string"
    exit 3
fi

terms1=$(egrep "^${2}=.*" "${1}" | cut -d '=' -f 2 | tr ' ' '\n' )
terms2=$(egrep "^${3}=.*" "${1}" | cut -d '=' -f 2 | tr ' ' '\n' )

for line in ${terms2} ;
do
    if ! echo "${terms1}" | grep -qxF "${line}" ;
    then
       result+="${line} "
    fi
done

sed -i -E "s:(${3}=).*:\1${result}:g" "${1}"

2017-SE-01
Напишете скрипт, който получава задължителен първи позиционен параметър – директория и незадължителен втори – число. Скриптът трябва да проверява подадената директория и нейните под-директории и да извежда имената на:
а) при подаден на скрипта втори параметър – всички файлове с брой hardlink-ове поне равен на
параметъра;
б) при липса на втори параметър – всички symlink-ове с несъществуващ destination (счупени symlinkове).
Забележка:За удобство приемаме, че ако има подаден втори параметър, то той е число

#!/bin/bash

if [[ ! -d "${1}" ]] ;
then
    echo "First parameter should be a directory"
    exit 1
fi

if [[ "${#}" -eq 2 ]] ;
then
    if [[ "${2}" =~ ^[0-9]+$ ]] ;
    then
        find "${1}" -mindepth 1 -type f  -exec stat -c "%h %n\n" {} \; | awk -v var=${2} '{if ($1>=var) print $2}'
    else
        echo "Invalid second parameter"
        exit 2
    fi
elif [[ "${#}" -eq 1 ]] ;
then
    find "${1}" -mindepth 1 -type l -exec test ! -e {} \; -print
fi

2017-SE-02 
Напишете скрипт, който приема три задължителни позиционни параметра - директория
SRC, директория DST (която не трябва да съдържа файлове) и низ АBC. Ако скриптът се изпълнява
от root потребителя, то той трябва да намира всички файлове в директорията SRC и нейните поддиректории, 
които имат в името си като под-низ АBC, и да ги мести в директорията DST, запазвайки
директорийната структура (но без да запазва мета-данни като собственик и права, т.е. не ни интересуват 
тези параметри на новите директории, които скриптът би генерирал в DST).
Пример:
• в SRC (/src) има следните файлове:
/src/foof.txt
/src/1/bar.txt
/src/1/foo.txt
/src/2/1/foobar.txt
/src/2/3/barf.txt
• DST (/dst) е празна директория
• зададения низ е foo
Резултат:
• в SRC има следните файлове:
/src/1/bar.txt
/src/2/3/barf.txt
• в DST има следните файлове:
8
/dst/foof.txt
/dst/1/foo.txt
/dst/2/1/foobar.txt


#!/bin/bash

if [[ "${#}" -ne 3 ]] ;
then
    echo "There should be 3 parameters"
    exit 1
fi

src="${1}"

if [[ ! -d "${src}" ]] ;
then
    echo "1st param should be a directory"
    exit 2
fi

dst="${2}"

if [[ -d "${dst}" ]] ;
then
    if [[  $(find "${dst}" -mindepth 1 | wc -l) -ne 0 ]] ;
    then
        echo "The destination folder should be empty"
        exit 3
    fi
else
    echo "Incorrect dest dir"
    exit 4
fi

abc="${3}"
if [[ -z "${abc}" ]]
then
    echo "Empty string"
    exit 5
fi

if [[ $(id -u) -ne 0 ]] ;
then
    echo "Only root cat execute this script"
    exit 6
fi

files=$(find "${src}" -type f -name "*${abc}*")
echo "${files}"
for file in $files ;
do
    src_path=$(realpath "${src}")
    path=$(realpath "${file}" | rev | cut -d '/' -f 2- | rev | sed "s:^${src_path}/::g")
    mkdir -p "${dst}/${path}"

    mv "${file}" "${dst}/${path}/"

done



2018-SE-02 
Напишете скрипт, който приема два позиционни аргумента – име на текстови файл и
директория. Директорията не трябва да съдържа обекти, а текстовият файл (US-ASCII) е стенограма
и всеки ред е в следния формат:
ИМЕ ФАМИЛИЯ (уточнения): Реплика
където:
• ИМЕ ФАМИЛИЯ присъстват задължително;
• ИМЕ и ФАМИЛИЯ се състоят само от малки/главни латински букви и тирета;
• (уточнения) не е задължително да присъстват;
• двоеточието ‘:’ присъства задължително;
10
• Репликата не съдържа знаци за нов ред;
• в стринга преди двоеточието ‘:’ задължително има поне един интервал между ИМЕ и ФАМИЛИЯ;
• наличието на други интервали където и да е на реда е недефинирано.
Примерен входен файл:
John Lennon (The Beatles): Time you enjoy wasting, was not wasted.
Roger Waters: I'm in competition with myself and I'm losing.
John Lennon:Reality leaves a lot to the imagination.
Leonard Cohen:There is a crack in everything, that's how the light gets in.
Скриптът трябва да:
• създава текстови файл dict.txt в посочената директория, който на всеки ред да съдържа:
ИМЕ ФАМИЛИЯ;НОМЕР
където:
– ИМЕ ФАМИЛИЯ е уникален участник в стенограмата (без да се отчитат уточненията);
– НОМЕР е уникален номер на този участник, избран от вас.
• създава файл НОМЕР.txt в посочената директория, който съдържа всички (и само) редовете на
дадения участник.

 #!/bin/bash

if [[ ${#} -ne 2 ]] ;
then
    echo "Invalid number of parameters"
    exit 1
fi

file=${1}
dir=${2}

if [[ ! -f "${file}" ]] ;
then
    echo "Invalid file parameter"
    exit 2
fi

if [[ ! -d "${dir}"  ]] ;
then
    echo "Invalid directory parameter"
    exit 3
fi

valid_lines=$(egrep "^[a-zA-Z-]+ [a-zA-Z-]+( \(.*\))?:.*" "${file}")

if [[ ! -f "${dir}/dict.txt" ]] ;
then
    touch "${dir}/dict.txt"
fi

dict="${dir}/dict.txt"
counter=1

while read person ;
do
    if grep -q "${person}" "${dict}" ;
    then
        continue
    fi
    echo "${person}:${counter}" >> "${dict}"
    if [[ ! -f "${counter}" ]] ;
    then
        touch "${dir}/${counter}.txt"
    fi

    grep "${person}" <(echo "${valid_lines}") | cut -d ":" -f 2  | sed "s:^ ::g" > ${dir}/${counter}.txt
    ((counter+=1 ))
done < <(echo "${valid_lines}" | cut -d ':' -f 1 | sed "s:(.*)::g" | sort | uniq ) ;


2018-SE-03 Напишете скрипт, който приема два позиционни аргумента – имена на текстови файлове
в CSV формат:
8,foo,bar,baz
2,quz,,foo
12,1,3,foo
3,foo,,
5,,bar,
7,,,
4,foo,bar,baz
Валидни са следните условия:
• CSV файловете представляват таблица, като всеки ред на таблицата е записан на отделен ред;
• на даден ред всяко поле (колона) е разделено от останалите със запетая;
• броят на полетата на всеки ред е константа;
• в полетата не може да присъства запетая, т.е., запетаята винаги е разделител между полета;
• ако във файла присъстват интервали, то това са данни от дадено поле;
• първото поле на всеки ред е число, което представлява идентификатор на реда (ID).
Примерно извикване: ./foo.sh a.csv b.csv
Скриптът трябва да чете a.csv и на негова база да създава b.csv по следния начин:
• някои редове във файла се различават само по колоната ID, и за тях казваме, че формират множество 𝐴𝑖
• за всяко такова множество 𝐴𝑖
да се оставя само един ред - този, с най-малка стойност на ID-то;
• редовете, които не са членове в някое множество 𝐴𝑖
се записват в изходния файл без промяна.

#!/bin/bash

if [[ "${#}" -ne 2 ]] ;
then
    echo "Two parameters"
    exit 1
fi

input="${1}"

if [[ ! -f "${input}" ]] ;
then
    echo "Invalid file"
    exit 2
fi

output="${2}"
if [[ -e "${output}" ]] ;
then
    > "${output}"
else
    touch "${output}"
fi

removed_id=$(cut -d ',' -f 2- "${input}" | sort | uniq)
while read line ;
do
    count=$(egrep -o "^[0-9]+,${line}$" "${input}" | wc -l)
    if [[ "${count}" -lt 2 ]] ;
    then
        whole_line=$(egrep "^[0-9]+,${line}$" "${input}")
        echo "${whole_line}" >> "${output}"
    else
        echo "$(egrep "^[0-9]+,${line}$" "${input}" | sort -n -k 1 -t ',' | head -n 1)" >> "${output}"
    fi
done <<< "${removed_id}"


2019-SE-01 Напишете два скрипта (по един за всяка подточка), които четат редове от STDIN. Скриптовете трябва да обработват само редовете, които съдържат цели положителни или отрицателни числа;
останалите редове се игнорират. Скриптовете трябва да извежда на STDOUT:
а) всички уникални числа, чиято абсолютна стойност е равна на максималната абсолютна стойност сред всички числа
б) всички най-малки уникални числа от тези, които имат максимална сума на цифрите си
Примерен вход:
We don't
n11d n0
educat10n
11
12.3
6
33
-42
-42
111
111
-111
Примерен изход за а):
-111
111
Примерен изход за б):
-42


a)
#!/bin/bash

numbers_file=$(mktemp)

while read line ;
do
    if [[ ${line} =~ ^((-)?[0-9]+( )?)+$ ]] ;
    then
        echo "${line}" >> "${numbers_file}"
    fi
done

sed "s: :\n:g"

max=$(cat "${numbers_file}" | tr -d '-' | sort -n -r | head -n 1)

echo "Result:"
cat "${numbers_file}" | egrep "^(-)?${max}$" | sort | uniq


b)
#!/bin/bash

temp=$(mktemp)

while read line ;
do
    if [[ ${line} =~ ^((-)?[0-9]+( )?)+$ ]] ;
    then
        echo "${line}" >> "${temp}"
    fi
done

max_sum=0
max_sum_num=0
nums_with_sums=$(mktemp)

while read line ;
do
    current_sum=$(echo "${line}" | sed -E "s:-?([0-9]):\1\n:g" | awk '{sum += $1} END {print sum}')
    echo "${line} ${current_sum}" >> "${nums_with_sums}"

    if [[ ${current_sum} -gt ${max_sum} ]] ;
    then
        max_sum=${current_sum}
        max_sum_num=${line}
    fi
done < <(cat "${temp}" | tr ' ' '\n')

echo "Result:"
cat "${nums_with_sums}" | egrep "^-?[0-9]+ ${max_sum}$" | sort -n -k 1 | head -n 1 | cut -d ' ' -f 1


2019-SE-02 
Напишете шел скрипт, който приема множество параметри. Общ вид на извикване:
./foo.sh [-n N] FILE1...
В общия случай параметрите се третират като имена на (.log) файлове, които трябва да бъдат обработени от скрипта, със следното изключение: ако първият параметър е стрингът -n, то вторият параметър е число, дефиниращо стойност на променливата N, която ще ползваме в скрипта. Въвеждаме
понятието идентификатор на файл (ИДФ), което се състои от името на даден файл без разширението
.log. За удобство приемаме, че скриптът:
• ще бъде извикван с аргументи имена на файлове, винаги завършващи на .log
• няма да бъде извикван с аргументи имена на файлове с еднакъв ИДФ.
Лог файловете са текстови, като всеки ред има следния формат:
• време: timestamp във формат YYYY-MM-DD HH:MM:SS
• интервал
• данни: поредица от символи с произволна дължина
За удобство приемаме, че редовете във всеки файл са сортирани по време възходящо.
Примерно съдържание на даден лог файл:
2019-05-05 06:26:54 orthanc rsyslogd: rsyslogd was HUPed
2019-05-06 06:30:32 orthanc rsyslogd: rsyslogd was HUPed
2019-05-06 10:48:29 orthanc kernel: [1725379.728871] Chrome_~dThread[876]: segfault
Скриптът трябва да извежда на STDOUT последните N реда (ако N не е дефинирано - 10 реда) от всеки
файл, в следния формат:
• timestamp във формат YYYY-MM-DD HH:MM:SS
• интервал
• ИДФ
• интервал
• данни
Изходът трябва да бъде глобално сортиран по време възходящо.


#!/bin/bash

if [[ "${1}" == "-n" ]] ;
then
    if [[ ! "${2}" =~ ^[0-9]+$ ]] ;
    then
        echo "Invalid N"
        exit 1
    else
        N="${2}"
    fi
    shift
    shift
else
    N=10
fi

for file in "${@}" ;
do
    if [[ ! -f "${file}" || ! "${file}" =~ .*\.log ]] ;
    then
        echo "Invalid argument"
        exit 1
    fi
done

for file in "${@}" ;
do
   content="$(cat "${file}")"
   idf="$(echo "${file}" | sed -E 's:\.log::g')"
   first_part=$(echo "${content}" | cut -d ' ' -f 1,2)
   second_part=$(echo "${content}" | cut -d ' ' -f 3-)
   echo "${first_part} ${idf} ${second_part}"
done | sort | head -n "${N}"
